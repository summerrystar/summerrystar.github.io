<html>
    <head>
        <style>
            .column {
                float:  center;
                margin-left:  10%;
                margin-right: 10%
            }

            .collapsible {
                background-color: #f1f1f1;
                cursor: pointer;
                padding: 10px;
                width: 100%;
                border: none;
                text-align: left;
                outline: none;
                font-size: 15px;
            }

            .collapsible.active, .collapsible:hover {
                background-color: #dfdfdf;
            }

            .collapsible:after {
                content: '\002B';
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }

            .collapsible.active:after {
                content: "\2212";
            }

            .content {
                padding: 0 18px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #f1f1f1;
            }

            iframe{
                border: none;
                width: 90%;
            }

            #fixed_box{
                bottom: 1%;
                right: 1%;
                text-align: center;
                position: fixed;
            }
            .btn_exp_coll {
                display: inline-block;
                background-color:cadetblue;
                border-radius: 10px;
                border: 4px double #cccccc;
                color: #ffffff;
                text-align: center;
                padding: 15px;
                width: 200px;
                transition: all 0.5s;
                cursor: pointer;
                margin: 5px;
                font-weight: bold;
            }
            .btn_exp_coll span {
                cursor: pointer;
                display: inline-block;
                position: relative;
                transition: 0.5s;
            }
            .btn_exp_coll span:after {
                content: '\00bb';
                position: absolute;
                opacity: 0;
                top: 0;
                right: -20px;
                transition: 0.5s;
            }
            .btn_exp_coll:hover {
                background-color:tan
            }
            .btn_exp_coll:hover span {
                padding-right: 25px;
            }
            .btn_exp_coll:hover span:after {
                opacity: 1;
                right: 0;
            }

        </style>
        <title>Transmission Line, Reflection, Termination 传输线，反射与端接</title>
    </head>
    <body>
        <h1 style="text-align: center;">Transmission Line, Reflection, Termination 传输线，反射与端接</h1>
        <div class="column">
            <div id="fixed_box">
                <button class="btn_exp_coll" onclick="expandCollapse()"><span>Expand/Collapse All</span></button>
                <!-- <br> -->
                <!-- <button onclick="collapseAll()">Collapse All</button> -->
            </div>
            <h3>Transmission Line & Reflection</h3>
            <p>现代电路的两个特点：信号的rise/fall time越来越快；wire连接越来越长。此时如果driver, transmission line和receiver的impedance不match，有discontinuity，就会产生reflection，导致各种undershoot和overshoot。</p>
            
            
            <button class="collapsible">Water analogy</button>
            <div class="content">
                <ul>
                    <li>水流动时如果受到均匀的阻力，就能比较平稳地到达对岸。但如果不均匀，就会产生反射的水波。</li>
                    <li>    
                        <iframe onload="resizeIframe(this)" src="pcb_figures-Page-2.drawio.html"></iframe>
                    </li>
                    <li>考虑上图的情况，信号从driver出发，先流过一段长通道，每一小段unit length的阻力都是50Ω，于是信号平稳流过。</li>
                    <li>然而到达RX端时，突然遇到1MΩ的"brick wall"，产生反射信号。这一反射信号再次从Z<sub>0</sub>流回TX端。</li>
                    <li>图中TX端看进去的impedance是50Ω，因此反射信号不会再次产生reflection。但如果TX端的impedance与transmission line不match，则会再次产生反射信号。这些信号将在TX和RX之间震荡，直到最终damp out。</li>

                </ul>
                
                <p>
                以上可以解释为何trace impedance只和width有关，而和length无关。因为信号是逐步流过每一段unit length。Length会影响的是delay：如果delay短的话，the ringing will damp out faster，信号能更快settle。
                </p>
            </div>
            
            <br>

            <button class="collapsible">Reflection coefficient的计算</button>
            <div class="content">

                <p>Reflection coefficient的计算是根据driver impedance (R<sub>D</sub>)和transmission line impedance Z<sub>0</sub>：</p>
                <p style="text-align: center;">ρ = (R<sub>D</sub>-Z<sub>0</sub>) / (R<sub>D</sub>+Z<sub>0</sub>)</p>
                <p>这个coefficient会在-1到1之间。理解以下3种情况：
                    <ul>
                        <li>ρ=-1：说明R<sub>D</sub> = 0，表示short circuit</li>
                        <li>ρ=1：说明R<sub>D</sub> = ∞，表示open circuit</li>
                        <li>ρ=0：No reflection – ideal situation。</li>
                    </ul>
                    
                </p>
            </div>



            <h3>Termination</h3>
            <p>Termination的作用就是match impedance，防止reflection。在TX and/or RX端加termination resistor，来保证他们的impedance是50Ω。以下是两种最基础的设计。平时最常用的是RX的parallel termination。如果只有TX termination，有两大问题：依然会有一次reflection，以及只适用于point-to-point。详见Differential Example中的解释。</p>

            <div style="width: 50%; float: left;">
                Series termination @ TX:
                <iframe onload="resizeIframe(this)" src="pcb_figures-Page-3.drawio.html"></iframe>
            </div>
            <div style="width: 50%; float: left;">
                Parallel termination @ RX:
                <iframe onload="resizeIframe(this)" src="pcb_figures-Page-4.drawio.html"></iframe>
            </div>
            

            <button class="collapsible">从波形快速判断问题</button>
            <div class="content">
                <table>
                    <tr>
                        <td>以series termination为例：</td>
                        <td><iframe onload="resizeIframe(this)" src="pcb_figures-Page-6.drawio.html"></iframe></td>
                    </tr>
                </table>
                
                <iframe style="display: block; margin-left: auto; margin-right: auto;" onload="resizeIframe(this)" src="pcb_figures-Page-5.drawio.html"></iframe>

            </div>

            <p>更多topology及优缺点：</p>
            <button class="collapsible">Single-Ended Examples</button>
            <div class="content">
                <table>
                    <tr>
                        <td>
                            <b>Series Termination</b> (TX)
                            <iframe onload="resizeIframe(this)" src="pcb_figures-Page-3.drawio.html"></iframe>
                        </td>
                        <td>
                            <ul>
                                <li>好处：low power dissipation, good noise reduction, low cost, space saving</li>
                                <li>坏处：会reduce rise time, hard to define resistance value, cannot use in daisy-chain topologies</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>Parallel Termination</b> (RX)
                            <iframe onload="resizeIframe(this)" src="pcb_figures-Page-7.drawio.html"></iframe>
                        </td>
                        <td>
                            <ul>
                                <li>好处：不加delay、不影响rise time，low cost, good for distributive loads (daisy-chain topology)</li>
                                <li>坏处：more power dissipation</li>
                            </ul>       
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>Thevenin's Termination</b> (RX)
                            <iframe onload="resizeIframe(this)" src="pcb_figures-Page-8.drawio.html"></iframe>
                        </td>
                        <td>
                            <ul>
                                <li>好处：no delay, good reflection attenuation, <mark>level adaptation</mark> is possible（比如说3.3V LVPECL和2.5V LVPECL用不同的R<sub>TH</sub>/R<sub>TL</sub>数值组合）</li>
                                <li>坏处：takes more space (needs 2 resistors), high cost, additional power dissipation</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>Diode Termination</b> (RX)
                            <iframe onload="resizeIframe(this)" src="pcb_figures-Page-9.drawio.html"></iframe>
                        </td>
                        <td>
                            <ul>
                                <li>称作”clamping diodes”。原先出来的signal会有overshoot和undershoot，用diode把它们clamp掉</li>
                                <li>这个技巧用得很少</li>
                                <li>好处：no additional power dissipation, easy placement of clamping diodes</li>
                                <li>坏处：switching time of diode should be equal to rise/fall time of signal – hard to find suitable part in the market</li>
                            </ul>
                        </td>
                    </tr>
                </table>

            </div>

            <br>

            <button class="collapsible">Differential Examples</button>
            <div class="content">
                (<a href="https://www.ti.com/lit/an/snla034b/snla034b.pdf">Reference</a>)
                <table>
                    <tr>
                        <td style="width:50%">
                            <b>Unterminated</b>
                        </td>
                        <td>
                            <img style="width: 70%;" src="diff_term_1.png"></img>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2">
                            <ul>
                                <li>这种情况通常twisted pair是50Ω，是否有reflection完全取决于TX和RX的impedance。信号先从50Ω传到RX，如果RX的impedance高的话，就会将signal reflect back。而这个reflected signal到达TX会看到TX的impedance，如果mismatch则会再次reflect。（</li>
                                <li>如果data rate低，能保证这些reflection有足够的时间settle到steady state（在下一个transition前）。如果cable短，则能保证back and forth reflection settle down的时间很短。这两个条件满足的话，可以使用unterminated。</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>Series Termination</b>
                        </td>
                        <td>
                            <img style="width: 70%;" src="diff_term_2.png"></img>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2">
                            <ul>
                                <li>RX端没有termination，依然会产生reflection，但当reflected信号传回TX端，却会见到matched impedance而被terminate</li>
                                <li>也就是说，依然会有一次reflection，时间为one round trip cable delay</li>
                                <li>这个termination的几个问题：</li>
                                <ul>
                                    <li>由于有process variation，TX的output impedance可能会vary，然后designer不得不根据这个impedance来设计transmission line。假如一块板子上TX元件坏了，换了另一个，而impedance变了，就不得不对这个板的trace进行rework</li>
                                    <li>只适用于Point-to-point。如果同一个TX drive多个RX的话，到每一个RX的路径不同，noise margin会变</li>
                                </ul>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>Parallel Termination</b>
                            
                        </td>
                        <td><img style="width: 60%;" src="diff_term_3.png"></img></td>
                    </tr>
                    <tr>
                        <td colspan="2">
                            <ul><li>基本是最常用的。可以支持multidrop applications，但是要注意stub length。另外driver的output swing会减少，导致noise margin压缩。</li></ul>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>AC termination, Power termination</b>
                        </td>
                        <td>
                            <img style="width: 45%; float: left;" src="diff_term_4.png"></img>
                            <img style="width: 45%; float: left;" src="diff_term_5.png"></img>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2">
                            <ul><li>这两种parallel termination的variation各自解决了parallel本身的一些问题。此处略过，详见Reference。</li></ul>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <b>Bidirectional termination</b>
                        </td>
                        <td>
                            <img style="width: 70%;" src="diff_term_6.png"></img></td>
                    </tr>
                    <tr>
                        <td colspan="2">
                            <ul>
                                <li>由于两边都有TX和RX，所以两边都要用parallel termination</li>
                                <li>优缺点详见Reference。</li>
                            </ul>
                        </td>
                    </tr>
                </table>
                <hr>
                <b>进阶：split termination</b> (<a href="https://community.silabs.com/s/share/a5U1M000000ko0gUAA/timing-101-the-case-of-the-split-termination?language=en_US">Reference 1</a>, <a href="http://www.sigcon.com/Pubs/edn/DifferentialTermination.htm">Reference 2</a>)
                <img style="width: 90%; display: block; margin-left: auto; margin-right: auto;" src="diff_term_7.png"></img>
                <p>
                    左边的termination理论上能用，但实际上大家都会用右边。这是因为现实中的信号有nonideality。理论上，differential signal应该完美相反。但考虑common mode的存在，即短时间内两根线上的voltage相等而不是相反。当common mode信号到达termination resistor的两端时，由于resistor上不会产生电流，相当于碰到了open circuit，于是所有common mode noise全部被reflect，而且会在TX和RX之间不停震荡叠加。这时，右边电路中加上的电容相当于enforced a practical AC GND at the center-tap。当CM 信号到达，能产生电流，相当于CM信号也能见到某种意义上的matching impedance（impedance大小由cap决定）。
                    
                </p>
                <p>
                    产生CM noise的原因很多，其中之一就是differential的两根线delay并不完全相同，正信号和负信号之间有一个小的delta。如果是这个原因，那么在选择cap的size的时候，只要能够在这个delta时间内hold the charge steady，那么大小就足够了。或者可以从频域的角度来看，将这个termination看作一个low-pass filter，计算他的corner frequency，公式为f<sub>c</sub> = 1/(2π<sup>R</sup>&frasl;<sub>2</sub>C)。只要选择corner frequency低到能过滤掉大部分CM noise即可。（比如R = 50Ω, C = 0.1uF的话，corner freq = 64kHz，就是一个不错的数字）
                </p>
            </div>




        </div>

        <br>
        <br>
        <br>
        <br>
        <br>

        <script>
            
            /* Collapsibles */
            var coll = document.getElementsByClassName("collapsible");
            var i;

            for (i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    var content = this.nextElementSibling;
                    if (content.style.maxHeight){
                        content.style.maxHeight = null;
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                    } 
                });
            }
            
            function resizeIframe(iframe) {
                var scroll_height = Number(iframe.contentWindow.document.body.scrollHeight);
                scroll_height = scroll_height * 1.2;    // Scale a bit larger to make sure no scroll bar shows
                iframe.height = scroll_height + "px";
            }

            function expandAll(){
                for (i = 0; i < coll.length; i++) {   
                    if (!coll[i].classList.contains("active")){
                        coll[i].classList.add("active")
                    }
                    var content = coll[i].nextElementSibling;
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            }

            function collapseAll(){
                for (i = 0; i < coll.length; i++) {   
                    if (coll[i].classList.contains("active")){
                        coll[i].classList.remove("active")
                    }
                    var content = coll[i].nextElementSibling;
                    content.style.maxHeight = null;
                }
            }

            function expandCollapse(){
                var coll_exist = 0;
                for (i = 0; i < coll.length; i++) {   
                    if (!coll[i].classList.contains("active")){
                        coll_exist = 1;
                        break;
                    }
                }
                if (coll_exist){
                    expandAll()
                }
                else{
                    collapseAll()
                }
            }

        </script>
    </body>
</html>