<html>
    <head>
        <style>
            .column {
                float:  center;
                margin-left:  10%;
                margin-right: 10%
            }

            .collapsible {
                background-color: #f1f1f1;
                cursor: pointer;
                padding: 10px;
                width: 100%;
                border: none;
                text-align: left;
                outline: none;
                font-size: 15px;
            }

            .collapsible.active, .collapsible:hover {
                background-color: #dfdfdf;
            }

            .collapsible:after {
                content: '\002B';
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }

            .collapsible.active:after {
                content: "\2212";
            }

            .content {
                padding: 0 18px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #f1f1f1;
            }

            iframe{
                border: none;
                width: 90%;
            }

        </style>
        <title>Transmission Line, Reflection, Termination 传输线，反射与端接</title>
    </head>
    <body>
        <h1 style="text-align: center;">Transmission Line, Reflection, Termination 传输线，反射与端接</h1>
        <div class="column">

            <h3>Transmission Line & Reflection</h3>
            <p>现代电路的两个特点：信号的rise/fall time越来越快；wire连接越来越长。此时如果driver, transmission line和receiver的impedance不match，有discontinuity，就会产生reflection，导致各种undershoot和overshoot。</p>
            
            
            <button class="collapsible">Water analogy</button>
            <div class="content">
                <ul>
                    <li>水流动时如果受到均匀的阻力，就能比较平稳地到达对岸。但如果不均匀，就会产生反射的水波。</li>
                    <li>    
                        <iframe onload="resizeIframe(this)" src="pcb_figures-Page-2.drawio.html"></iframe>
                    </li>
                    <li>考虑上图的情况，信号从driver出发，先流过一段长通道，每一小段unit length的阻力都是50Ω，于是信号平稳流过。</li>
                    <li>然而到达RX端时，突然遇到1MΩ的"brick wall"，产生反射信号。这一反射信号再次从Z<sub>0</sub>流回TX端。</li>
                    <li>图中TX端看进去的impedance是50Ω，因此反射信号不会再次产生reflection。但如果TX端的impedance与transmission line不match，则会再次产生反射信号。这些信号将在TX和RX之间震荡，直到最终damp out。</li>

                </ul>
                
                <p>
                以上可以解释为何trace impedance只和width有关，而和length无关。因为信号是逐步流过每一段unit length。Length会影响的是delay：如果delay短的话，the ringing will damp out faster，信号能更快settle。
                </p>
            </div>
            
            <br>

            <button class="collapsible">Reflection coefficient的计算</button>
            <div class="content">

                <p>Reflection coefficient的计算是根据driver impedance (R<sub>D</sub>)和transmission line impedance Z<sub>0</sub>：</p>
                <p style="text-align: center;">ρ = (R<sub>D</sub>-Z<sub>0</sub>) / (R<sub>D</sub>+Z<sub>0</sub>)</p>
                <p>这个coefficient会在-1到1之间。理解以下3种情况：
                    <ul>
                        <li>ρ=-1：说明R<sub>D</sub> = 0，表示short circuit</li>
                        <li>ρ=1：说明R<sub>D</sub> = ∞，表示open circuit</li>
                        <li>ρ=0：No reflection – ideal situation。</li>
                    </ul>
                    
                </p>
            </div>



            <h3>Termination</h3>
            <p>Termination的作用就是match impedance，防止reflection。在TX and/or RX端加termination resistor，来保证他们的impedance是50Ω。以下是两种最基础的设计。平时最常用的是RX的parallel termination。</p>

            <div style="width: 50%; float: left;">
                Series termination @ TX:
                <iframe onload="resizeIframe(this)" src="pcb_figures-Page-3.drawio.html"></iframe>
            </div>
            <div style="width: 50%; float: left;">
                Parallel termination @ RX:
                <iframe onload="resizeIframe(this)" src="pcb_figures-Page-4.drawio.html"></iframe>
            </div>

            <p>如果只terminate TX：</p>
            <ul>
                <li>虽然RX端依然会产生reflection，但当reflected信号传回TX端，却会见到matched impedance而被terminate。</li>
                <li>也就是说，依然会有一次reflection，线路的长短决定了这一次reflection多久能settle到steady state（one round trip cable delay）。</li>
                <li>只适用于Point-to-point。如果同一个TX drive多个RX的话，到每一个RX的路径不同，noise margin会变</li>
            </ul>
            


            <button class="collapsible">从波形快速判断问题</button>
            <div class="content">
                <p>以series termination为例：</p>
                <p>TODO</p>
            </div>

            <p>更多topology及优缺点：</p>
            <button class="collapsible">Single-Ended Examples</button>
            <div class="content">
                <p><b>Series Termination</b> (TX)</p>
                TODO: 插图
                <ul>
                    <li>好处：low power dissipation, good noise reduction, low cost, space saving</li>
                    <li>坏处：会reduce rise time, hard to define resistance value, cannot use in daisy-chain topologies</li>
                </ul>
                <p><b>Parallel Termination</b> (RX)</p>
                <p><b>Thevenin's Termination</b> (RX)</p>
                <p><b>Diode Termination</b> (RX)</p>
            </div>

            <br>

            <button class="collapsible">Differential Examples</button>
            <div class="content">
                TODO
            </div>




        </div>

        <script>
            
            /* Collapsibles */
            var coll = document.getElementsByClassName("collapsible");
            var i;

            for (i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    var content = this.nextElementSibling;
                    if (content.style.maxHeight){
                        content.style.maxHeight = null;
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                    } 
                });
            }
            
            function resizeIframe(iframe) {
                var scroll_height = Number(iframe.contentWindow.document.body.scrollHeight);
                scroll_height = scroll_height * 1.2;    // Scale a bit larger to make sure no scroll bar shows
                iframe.height = scroll_height + "px";
            }

        </script>
    </body>
</html>